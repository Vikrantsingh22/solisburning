const puppeteer = require("puppeteer");
require("dotenv").config();
const cheerio = require("cheerio");
const fs = require("fs");
const userAgents = [
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 Edg/123.0.2420.81",
  "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 OPR/109.0.0.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.4; rv:124.0) Gecko/20100101 Firefox/124.0",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_4_1) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Safari/605.1.15",
  "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_4_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36 OPR/109.0.0.0",
  "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
  "Mozilla/5.0 (X11; Linux i686; rv:124.0) Gecko/20100101 Firefox/124.0",
];
function getRandomUserAgent() {
  return userAgents[Math.floor(Math.random() * userAgents.length)];
}

/**
 * Improved URL processing with better handling of complex patterns
 * and enhanced validation
 */
function processUrls(urlString) {
  if (!urlString || urlString.trim() === "") {
    return [];
  }

  // Handle multiple possible URL formats and separators
  const urlPattern = /(https?:\/\/[^\s,]+)/g;
  const matches = urlString.match(urlPattern);

  if (!matches) {
    return [];
  }

  // Further process each extracted URL to handle edge cases
  const returnMatches = matches
    .map((url) => {
      // Remove trailing punctuation like commas or periods that might be included
      let cleanUrl = url.replace(/[,.!?]+$/, "");

      // Remove HTML tags if they exist
      cleanUrl = cleanUrl.replace(/<\/?[^>]+(>|$)/g, "");

      return cleanUrl.trim();
    })
    .filter((url) => {
      // Only include URLs that actually look like URLs
      return url.startsWith("http") && url.includes("://") && url.length > 10;
    });

  return returnMatches;
}

/**
 * Enhanced HTML description processing that better preserves structure
 * and handles a wider variety of content formats
 */
function processDescription(html) {
  if (!html || html.trim() === "") {
    return {
      plain_description: "",
      structured_content: { sections: [] },
    };
  }

  // First replace common HTML entities
  let processedHtml = html
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");

  // Extract sections with headings
  const sections = [];

  // Split by paragraph tags
  const paragraphs = processedHtml
    .split(/<\/?p>/g)
    .filter((p) => p.trim().length > 0);

  let currentTitle = null;
  let currentContent = "";

  for (let i = 0; i < paragraphs.length; i++) {
    const paragraph = paragraphs[i].trim();

    // Look for section headers wrapped in strong tags
    const strongMatch = paragraph.match(/<strong>(.*?)<\/strong>/);

    if (strongMatch) {
      // If we have existing content, save it as a section
      if (currentContent.trim().length > 0) {
        sections.push({
          title: currentTitle,
          content: cleanContent(currentContent),
        });
      }

      // Extract the title and any remaining content
      currentTitle = strongMatch[1].trim();
      currentContent = paragraph.replace(/<strong>.*?<\/strong>/, "").trim();
    } else {
      // If not a header, add to current content
      if (currentContent.length > 0 && paragraph.length > 0) {
        currentContent += " " + paragraph;
      } else {
        currentContent = paragraph;
      }
    }
  }

  // Add the last section if there's content
  if (currentContent.trim().length > 0) {
    sections.push({
      title: currentTitle,
      content: cleanContent(currentContent),
    });
  }

  // Create a clean plain text version for the entire content
  const plainDescription = stripHtmlTags(html);

  return {
    plain_description: plainDescription,
    structured_content: { sections },
  };
}

/**
 * Cleans and formats content text with improved handling of HTML and spacing
 */
function cleanContent(content) {
  return content
    .replace(/<br\s*\/?>/gi, " ") // Replace <br> tags with spaces
    .replace(/&nbsp;/g, " ") // Replace &nbsp; with spaces
    .replace(/\s+/g, " ") // Normalize whitespace
    .trim(); // Remove leading/trailing whitespace
}

/**
 * Enhanced HTML tag removal with better handling of whitespace and structure
 */
function stripHtmlTags(html) {
  if (!html) return "";

  return html
    .replace(/<br\s*\/?>/gi, " ") // Replace <br> tags with spaces
    .replace(/<\/?[^>]+(>|$)/g, "") // Remove all HTML tags
    .replace(/&nbsp;/g, " ") // Replace &nbsp; with spaces
    .replace(/\s+/g, " ") // Normalize whitespace
    .trim(); // Remove leading/trailing whitespace
}

/**
 * Determines if a project has been audited based on audit information
 */
function determineAuditStatus(auditInfo) {
  if (!auditInfo || !Array.isArray(auditInfo)) {
    return "Unknown";
  }

  // Check if any audit has a partner
  const hasPartner = auditInfo.some((audit) => audit.partner);

  // Check if any audit has an audit link
  const hasAuditLink = auditInfo.some((audit) => audit.audit_link);

  if (hasPartner || hasAuditLink) {
    return "Audited";
  } else if (auditInfo.length > 0) {
    return "Not Audited";
  } else {
    return "Unknown";
  }
}

/**
 * Formats dates into different formats for improved display
 */
function formatDate(dateString) {
  if (!dateString) {
    return null;
  }

  try {
    const dateObj = new Date(dateString);

    // Check if date is valid
    if (isNaN(dateObj.getTime())) {
      return null;
    }

    return {
      iso: dateString,
      display: dateObj.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      }),
      timestamp: dateObj.getTime(),
    };
  } catch (e) {
    return null;
  }
}

/**
 * Format currency values with more consistent display
 */
function formatCurrency(value) {
  if (value === null || value === undefined) {
    return { value: null, display: "$0.00" };
  }

  const formatter = new Intl.NumberFormat("en-US", {
    style: "currency",
    currency: "USD",
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });

  // Format for display with abbreviations
  let display;
  if (value >= 1000000000) {
    display = `$${(value / 1000000000).toFixed(2)}B`;
  } else if (value >= 1000000) {
    display = `$${(value / 1000000).toFixed(2)}M`;
  } else if (value >= 1000) {
    display = `$${(value / 1000).toFixed(2)}K`;
  } else {
    display = formatter.format(value);
  }

  return {
    value: value,
    display: display,
  };
}

/**
 * Processes and enhances the API data with improved error handling and validation
 * And removes specified properties and lines as requested
 */
function processApiData(data) {
  // Validate input
  if (!data) {
    return {
      items: [],
      meta: {
        total_items: 0,
        current_page: 1,
        last_page: 1,
        processed_at: new Date().toISOString(),
      },
    };
  }

  // If no items or items is not an array, return empty structure
  if (!data.items || !Array.isArray(data.items)) {
    return {
      ...data,
      items: [],
      meta: {
        total_items: 0,
        current_page: data.currentPage || 1,
        last_page: data.lastPage || 1,
        processed_at: new Date().toISOString(),
      },
    };
  }

  // Process each item in the array with improved error handling
  const processedItems = data.items.map((item) => {
    try {
      // Create a new object with only the properties we want to keep
      const processedItem = {};

      // Copy over properties that we want to keep
      processedItem.project_name = item.project_name;
      processedItem.name_categories = item.name_categories;
      processedItem.token_name = item.token_name;
      processedItem.proof_archive_link = item.proof_archive_link;
      processedItem.technical_issue = item.technical_issue;
      processedItem.token_address = item.token_address;
      processedItem.proof_link = processUrls(item.proof_link || "");
      processedItem.website_link = item.website_link;
      processedItem.webarchive_link = item.webarchive_link;
      processedItem.twitter_link = item.twitter_link;
      processedItem.telegram_link = item.telegram_link;
      processedItem.funds_lost = item.funds_lost;
      processedItem.funds_returned = item.funds_returned;
      processedItem.funds_recovered = item.funds_recovered;
      processedItem.active = item.active;
      processedItem.git_hub = item.git_hub;
      processedItem.git_hub_contract_link = item.git_hub_contract_link;
      processedItem.discord = item.discord;
      processedItem.bug_bounty_program_link = item.bug_bounty_program_link;
      processedItem.bug_bounty_program_company =
        item.bug_bounty_program_company;
      processedItem.network = item.network;

      // Add scam_type but remove the id property
      if (item.scam_type) {
        processedItem.scam_type = {
          name: item.scam_type.name,
          type: item.scam_type.type,
        };
      }

      // Process and modify auditedBy to remove the id field
      if (item.auditedBy && Array.isArray(item.auditedBy)) {
        processedItem.auditedBy = item.auditedBy.map((audit) => {
          return {
            date: audit.date,
            audit_link: audit.audit_link,
            partner: audit.partner,
          };
        });
      } else {
        processedItem.auditedBy = [];
      }

      // Process description to create structured content
      if (item.description) {
        const processedDescription = processDescription(item.description);
        processedItem.description = processedDescription.structured_content;
      }

      // Add audit status
      processedItem.audit_status = determineAuditStatus(item.auditedBy || []);

      // Process dates with better formatting and validation
      processedItem.date = formatDate(item.date);

      return processedItem;
    } catch (error) {
      console.error(`Error processing item ${item.id || "unknown"}:`, error);

      // Return a minimal processed item in case of error
      return {
        project_name: item.project_name || "Unknown Project",
        proof_links: processUrls(item.proof_link || ""),
        audit_status: "Unknown",
        processing_error: true,
      };
    }
  });

  // Return enhanced data structure
  return {
    ...data,
    items: processedItems,
    meta: {
      total_items: data.total || processedItems.length,
      current_page: data.currentPage || 1,
      last_page: data.lastPage || 1,
      processed_at: new Date().toISOString(),
      processing_version: "2.0.0",
    },
  };
}

const scrapeLogic = async (res) => {
  const browser = await puppeteer.launch({
    args: [
      "--disable-setuid-sandbox",
      "--no-sandbox",
      "--single-process",
      "--no-zygote",
    ],
    executablePath:
      process.env.NODE_ENV === "production"
        ? process.env.PUPPETEER_EXECUTABLE_PATH
        : puppeteer.executablePath(),
  });
  let valueFetched;
  let content;
  try {
    const url =
      "https://api.de.fi/v1/rekt/list?sortField=date&sort=desc&sortDirection=desc&limit=100&page=1&chains[]=1002";
    const page = await browser.newPage();
    const userAgent = getRandomUserAgent();
    await page.setUserAgent(userAgent);

    console.log("11111111111111111111111111");

    await page.setExtraHTTPHeaders({
      Accept:
        "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
      Referer: url,
    });

    console.log("2222222222222222");
    await page.goto(url, { waitUntil: "domcontentloaded" });

    await page.content();
    // Set screen size
    // console.log(content);
    // fs.writeFileSync("fortnite-tracker2.html", content);

    // Load the HTML content into Cheerio
    const innerText =
      (await page.evaluate(() => {
        return document.querySelector("body")?.innerText;
      })) || ""; // Get the inner text of the body

    const jsonResponse = processApiData(JSON.parse(innerText)); // Parse the JSON response

    console.log("44444444444444444");

    if (jsonResponse) {
      res.json({ code: 0, data: jsonResponse });
      console.log("555555555555555555555555555");
    } else {
      res.json({ code: 1, data: "content not found" });
      console.log("66666666666666666666666666666");
    }
  } catch (e) {
    console.log("errrrrrrrrrrrrrrrrrrrrrrrrr");
    console.error("Error scraping Fortnite Tracker due to the cloudfare:", e);
    res.json({ code: 2, data: "Error while Retrieveing data" });
  } finally {
    await browser.close();
  }
};

module.exports = { scrapeLogic };
